// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package postgres

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const copyPlaylist = `-- name: CopyPlaylist :one
WITH row_for_copy AS (
    SELECT id, title, author_id, cover_url, track_ids, created_at, updated_at, released_at, is_album, is_public
    FROM playlists
    WHERE playlists.id = $3::UUID AND
        playlists.is_public AND
        playlists.is_album = FALSE AND
        playlists.author_id != $2
)
INSERT INTO playlists (
    id,
    title,
    author_id,
    track_ids,
    cover_url,
    is_album,
    is_public,
    created_at
) SELECT
    $1::UUID as new_playlis_id,
    title,
    $2::UUID,
    track_ids,
    cover_url,
    FALSE,
    FALSE,
    NOW()
FROM row_for_copy
RETURNING id
`

type CopyPlaylistParams struct {
	NewPlaylistID uuid.UUID
	UserID        uuid.UUID
	PlaylistID    uuid.UUID
}

func (q *Queries) CopyPlaylist(ctx context.Context, arg CopyPlaylistParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, copyPlaylist, arg.NewPlaylistID, arg.UserID, arg.PlaylistID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deletePlaylists = `-- name: DeletePlaylists :exec
DELETE FROM playlists WHERE id = ANY($1::UUID[]) and author_id = $2::UUID
`

type DeletePlaylistsParams struct {
	Ids    []uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeletePlaylists(ctx context.Context, arg DeletePlaylistsParams) error {
	_, err := q.db.Exec(ctx, deletePlaylists, arg.Ids, arg.UserID)
	return err
}

const dislikePlaylist = `-- name: DislikePlaylist :exec
DELETE FROM liked_playlists WHERE liked_playlist = $1::UUID AND user_id = $2::UUID
`

type DislikePlaylistParams struct {
	PlaylistID uuid.UUID
	UserID     uuid.UUID
}

func (q *Queries) DislikePlaylist(ctx context.Context, arg DislikePlaylistParams) error {
	_, err := q.db.Exec(ctx, dislikePlaylist, arg.PlaylistID, arg.UserID)
	return err
}

const dislikeTrack = `-- name: DislikeTrack :exec
DELETE FROM liked_tracks WHERE track_id = $1::UUID AND user_id = $2::UUID
`

type DislikeTrackParams struct {
	TrackID uuid.UUID
	UserID  uuid.UUID
}

func (q *Queries) DislikeTrack(ctx context.Context, arg DislikeTrackParams) error {
	_, err := q.db.Exec(ctx, dislikeTrack, arg.TrackID, arg.UserID)
	return err
}

const likePlaylist = `-- name: LikePlaylist :one
WITH inserted_row AS (
    INSERT INTO liked_playlists (liked_playlist, user_id)
    SELECT id, $1::UUID
    FROM playlists
    WHERE id = $2::UUID AND (is_public OR author_id = $1::UUID)
    RETURNING liked_playlist)
SELECT liked_playlist FROM inserted_row
`

type LikePlaylistParams struct {
	UserID     uuid.UUID
	PlaylistID uuid.UUID
}

func (q *Queries) LikePlaylist(ctx context.Context, arg LikePlaylistParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, likePlaylist, arg.UserID, arg.PlaylistID)
	var liked_playlist uuid.UUID
	err := row.Scan(&liked_playlist)
	return liked_playlist, err
}

const likeTrack = `-- name: LikeTrack :one
WITH inserted_row AS (
    INSERT INTO liked_tracks (track_id, user_id)
    VALUES ($1::UUID, $2::UUID) ON CONFLICT (track_id, user_id) DO NOTHING
    RETURNING track_id)
SELECT track_id FROM inserted_row
`

type LikeTrackParams struct {
	TrackID uuid.UUID
	UserID  uuid.UUID
}

func (q *Queries) LikeTrack(ctx context.Context, arg LikeTrackParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, likeTrack, arg.TrackID, arg.UserID)
	var track_id uuid.UUID
	err := row.Scan(&track_id)
	return track_id, err
}

const myCollection = `-- name: MyCollection :many
SELECT
    track_id,
    liked_at
FROM liked_tracks
WHERE user_id = $1::UUID
ORDER BY liked_at DESC
`

type MyCollectionRow struct {
	TrackID uuid.UUID
	LikedAt time.Time
}

func (q *Queries) MyCollection(ctx context.Context, userID uuid.UUID) ([]MyCollectionRow, error) {
	rows, err := q.db.Query(ctx, myCollection, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MyCollectionRow
	for rows.Next() {
		var i MyCollectionRow
		if err := rows.Scan(&i.TrackID, &i.LikedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const patchPlaylist = `-- name: PatchPlaylist :one
UPDATE playlists SET
                 title = COALESCE($1, title),
                 cover_url = COALESCE($2, cover_url),
                 track_ids = COALESCE($3, track_ids),
                 released_at = COALESCE($4, released_at),
                 is_album = COALESCE($5, is_album),
                 is_public = COALESCE($6, is_public),
                 updated_at = $7::TIMESTAMPTZ
WHERE playlists.id = $8::UUID AND author_id = $9::UUID
RETURNING id, title, author_id, cover_url, track_ids, created_at, updated_at, released_at, is_album, is_public
`

type PatchPlaylistParams struct {
	Title      pgtype.Text
	CoverUrl   pgtype.Text
	TrackIds   []uuid.UUID
	ReleasedAt pgtype.Timestamptz
	IsAlbum    pgtype.Bool
	IsPublic   pgtype.Bool
	UpdatedAt  time.Time
	ID         uuid.UUID
	UserID     uuid.UUID
}

func (q *Queries) PatchPlaylist(ctx context.Context, arg PatchPlaylistParams) (Playlist, error) {
	row := q.db.QueryRow(ctx, patchPlaylist,
		arg.Title,
		arg.CoverUrl,
		arg.TrackIds,
		arg.ReleasedAt,
		arg.IsAlbum,
		arg.IsPublic,
		arg.UpdatedAt,
		arg.ID,
		arg.UserID,
	)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.AuthorID,
		&i.CoverUrl,
		&i.TrackIds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReleasedAt,
		&i.IsAlbum,
		&i.IsPublic,
	)
	return i, err
}

const playlist = `-- name: Playlist :one
SELECT
    playlists.id, playlists.title, playlists.author_id, playlists.cover_url, playlists.track_ids, playlists.created_at, playlists.updated_at, playlists.released_at, playlists.is_album, playlists.is_public
FROM playlists
WHERE id = $1
`

type PlaylistRow struct {
	Playlist Playlist
}

func (q *Queries) Playlist(ctx context.Context, id uuid.UUID) (PlaylistRow, error) {
	row := q.db.QueryRow(ctx, playlist, id)
	var i PlaylistRow
	err := row.Scan(
		&i.Playlist.ID,
		&i.Playlist.Title,
		&i.Playlist.AuthorID,
		&i.Playlist.CoverUrl,
		&i.Playlist.TrackIds,
		&i.Playlist.CreatedAt,
		&i.Playlist.UpdatedAt,
		&i.Playlist.ReleasedAt,
		&i.Playlist.IsAlbum,
		&i.Playlist.IsPublic,
	)
	return i, err
}

const publicPlaylists = `-- name: PublicPlaylists :many
SELECT
    playlists.id, playlists.title, playlists.author_id, playlists.cover_url, playlists.track_ids, playlists.created_at, playlists.updated_at, playlists.released_at, playlists.is_album, playlists.is_public
FROM playlists
WHERE
  -- Only public playlists!
    is_public AND (
    -- All albums created by some artists
    (($1::BOOLEAN) AND author_id = $2::UUID AND is_album) OR
        -- All playlists matching name
    ($3::BOOLEAN AND title ILIKE CONCAT('%', $4::TEXT, '%')) OR
        -- Playlists by IDs
    ($5::BOOLEAN AND id = ANY($6::UUID[]))
    )
ORDER BY created_at DESC, title
LIMIT $8
OFFSET $7
`

type PublicPlaylistsParams struct {
	ByArtistID bool
	ArtistID   uuid.UUID
	ByTitle    bool
	MatchName  string
	ByIds      bool
	Ids        []uuid.UUID
	Offsetv    int32
	Limitv     int32
}

type PublicPlaylistsRow struct {
	Playlist Playlist
}

func (q *Queries) PublicPlaylists(ctx context.Context, arg PublicPlaylistsParams) ([]PublicPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, publicPlaylists,
		arg.ByArtistID,
		arg.ArtistID,
		arg.ByTitle,
		arg.MatchName,
		arg.ByIds,
		arg.Ids,
		arg.Offsetv,
		arg.Limitv,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PublicPlaylistsRow
	for rows.Next() {
		var i PublicPlaylistsRow
		if err := rows.Scan(
			&i.Playlist.ID,
			&i.Playlist.Title,
			&i.Playlist.AuthorID,
			&i.Playlist.CoverUrl,
			&i.Playlist.TrackIds,
			&i.Playlist.CreatedAt,
			&i.Playlist.UpdatedAt,
			&i.Playlist.ReleasedAt,
			&i.Playlist.IsAlbum,
			&i.Playlist.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const savePlaylist = `-- name: SavePlaylist :exec
INSERT INTO playlists (
    id,
    title,
    author_id,
    track_ids,
    cover_url,
    is_album,
    created_at
) VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type SavePlaylistParams struct {
	ID        uuid.UUID
	Title     string
	AuthorID  uuid.UUID
	TrackIds  []uuid.UUID
	CoverUrl  pgtype.Text
	IsAlbum   bool
	CreatedAt time.Time
}

func (q *Queries) SavePlaylist(ctx context.Context, arg SavePlaylistParams) error {
	_, err := q.db.Exec(ctx, savePlaylist,
		arg.ID,
		arg.Title,
		arg.AuthorID,
		arg.TrackIds,
		arg.CoverUrl,
		arg.IsAlbum,
		arg.CreatedAt,
	)
	return err
}

const updatePlaylist = `-- name: UpdatePlaylist :one
UPDATE playlists SET
                 title = $2,
                 cover_url = $3,
                 track_ids = $4,
                 is_album = $5,
                 is_public = $6,
                 released_at = $7,
                 updated_at = $8
WHERE id = $1 AND author_id = $9::UUID
RETURNING id, title, author_id, cover_url, track_ids, created_at, updated_at, released_at, is_album, is_public
`

type UpdatePlaylistParams struct {
	ID         uuid.UUID
	Title      string
	CoverUrl   pgtype.Text
	TrackIds   []uuid.UUID
	IsAlbum    bool
	IsPublic   bool
	ReleasedAt pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
	UserID     uuid.UUID
}

func (q *Queries) UpdatePlaylist(ctx context.Context, arg UpdatePlaylistParams) (Playlist, error) {
	row := q.db.QueryRow(ctx, updatePlaylist,
		arg.ID,
		arg.Title,
		arg.CoverUrl,
		arg.TrackIds,
		arg.IsAlbum,
		arg.IsPublic,
		arg.ReleasedAt,
		arg.UpdatedAt,
		arg.UserID,
	)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.AuthorID,
		&i.CoverUrl,
		&i.TrackIds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReleasedAt,
		&i.IsAlbum,
		&i.IsPublic,
	)
	return i, err
}

const userPlaylists = `-- name: UserPlaylists :many
SELECT
    id,
    title,
    author_id,
    cover_url,
    created_at,
    updated_at,
    released_at,
    is_album,
    is_public
FROM playlists
WHERE playlists.author_id = $1::UUID
UNION
SELECT
    id,
    title,
    author_id,
    cover_url,
    created_at,
    updated_at,
    released_at,
    is_album,
    is_public
FROM playlists
LEFT JOIN liked_playlists ON playlists.id = liked_playlists.liked_playlist
WHERE liked_playlists.user_id = $1::UUID AND (playlists.is_public)
ORDER BY created_at DESC
`

type UserPlaylistsRow struct {
	ID         uuid.UUID
	Title      string
	AuthorID   uuid.UUID
	CoverUrl   pgtype.Text
	CreatedAt  time.Time
	UpdatedAt  pgtype.Timestamptz
	ReleasedAt pgtype.Timestamptz
	IsAlbum    bool
	IsPublic   bool
}

func (q *Queries) UserPlaylists(ctx context.Context, userID uuid.UUID) ([]UserPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, userPlaylists, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserPlaylistsRow
	for rows.Next() {
		var i UserPlaylistsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AuthorID,
			&i.CoverUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReleasedAt,
			&i.IsAlbum,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
