// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package postgres

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countMySongs = `-- name: CountMySongs :one
SELECT COUNT(*)::INT
FROM songs
WHERE singer_fk = $1::UUID
`

func (q *Queries) CountMySongs(ctx context.Context, singerID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, countMySongs, singerID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countSongsMatchName = `-- name: CountSongsMatchName :one
SELECT COUNT(*)::INT
FROM songs
WHERE name ILIKE CONCAT('%', $1::TEXT, '%')
`

func (q *Queries) CountSongsMatchName(ctx context.Context, matchName string) (int32, error) {
	row := q.db.QueryRow(ctx, countSongsMatchName, matchName)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countSongsWithArtistsIds = `-- name: CountSongsWithArtistsIds :one
WITH cte AS (
    SELECT COUNT(*)
    FROM songs
    WHERE singer_fk = ANY($1::UUID[])
)
SELECT COUNT(*)::INT + (SELECT count FROM cte)
FROM feats
WHERE artist_fk = ANY($1::UUID[])
`

func (q *Queries) CountSongsWithArtistsIds(ctx context.Context, singersIds []uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, countSongsWithArtistsIds, singersIds)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteSongs = `-- name: DeleteSongs :exec
DELETE FROM songs WHERE song_id = ANY($1::UUID[])
`

func (q *Queries) DeleteSongs(ctx context.Context, ids []uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSongs, ids)
	return err
}

const mySong = `-- name: MySong :one
SELECT songs.song_id, songs.singer_fk, songs.name, songs.s3_object_name, songs.image_url, songs.duration, songs.weight_bytes, songs.uploaded_at, songs.released_at
FROM songs
WHERE singer_fk = $1::UUID AND song_id = $2::UUID
`

type MySongParams struct {
	SingerID uuid.UUID
	SongID   uuid.UUID
}

type MySongRow struct {
	Song Song
}

func (q *Queries) MySong(ctx context.Context, arg MySongParams) (MySongRow, error) {
	row := q.db.QueryRow(ctx, mySong, arg.SingerID, arg.SongID)
	var i MySongRow
	err := row.Scan(
		&i.Song.SongID,
		&i.Song.SingerFk,
		&i.Song.Name,
		&i.Song.S3ObjectName,
		&i.Song.ImageUrl,
		&i.Song.Duration,
		&i.Song.WeightBytes,
		&i.Song.UploadedAt,
		&i.Song.ReleasedAt,
	)
	return i, err
}

const mySongs = `-- name: MySongs :many
SELECT
    songs.song_id, songs.singer_fk, songs.name, songs.s3_object_name, songs.image_url, songs.duration, songs.weight_bytes, songs.uploaded_at, songs.released_at,
    ARRAY_AGG(feats.artist_fk ORDER BY feats.order_num)::UUID[] AS artists_ids
FROM songs
LEFT JOIN feats ON feats.song_fk = songs.song_id
WHERE singer_fk = $1::UUID AND (NOT $2::BOOLEAN OR song_id = ANY($3::UUID[]))
GROUP BY songs.song_id
ORDER BY songs.uploaded_at DESC, name
LIMIT $5
OFFSET $4
`

type MySongsParams struct {
	SingerID uuid.UUID
	ByIds    bool
	Ids      []uuid.UUID
	Offsetv  int32
	Limitv   int32
}

type MySongsRow struct {
	Song       Song
	ArtistsIds []uuid.UUID
}

func (q *Queries) MySongs(ctx context.Context, arg MySongsParams) ([]MySongsRow, error) {
	rows, err := q.db.Query(ctx, mySongs,
		arg.SingerID,
		arg.ByIds,
		arg.Ids,
		arg.Offsetv,
		arg.Limitv,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MySongsRow
	for rows.Next() {
		var i MySongsRow
		if err := rows.Scan(
			&i.Song.SongID,
			&i.Song.SingerFk,
			&i.Song.Name,
			&i.Song.S3ObjectName,
			&i.Song.ImageUrl,
			&i.Song.Duration,
			&i.Song.WeightBytes,
			&i.Song.UploadedAt,
			&i.Song.ReleasedAt,
			&i.ArtistsIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const patchSong = `-- name: PatchSong :one
UPDATE songs SET
    singer_fk = COALESCE($1, singer_fk),
    name = COALESCE($2, name),
    s3_object_name = COALESCE($3, s3_object_name),
    image_url = COALESCE($4, image_url),
    duration = COALESCE($5, duration),
    weight_bytes = COALESCE($6, weight_bytes),
    released_at = COALESCE($7, released_at),
    uploaded_at = COALESCE($8, uploaded_at)
WHERE song_id = $9
RETURNING song_id, singer_fk, name, s3_object_name, image_url, duration, weight_bytes, uploaded_at, released_at
`

type PatchSongParams struct {
	SingerFk     pgtype.UUID
	Name         pgtype.Text
	S3ObjectName pgtype.Text
	ImageUrl     pgtype.Text
	Duration     pgtype.Interval
	WeightBytes  pgtype.Int4
	ReleasedAt   pgtype.Timestamptz
	UploadedAt   pgtype.Timestamptz
	ID           uuid.UUID
}

func (q *Queries) PatchSong(ctx context.Context, arg PatchSongParams) (Song, error) {
	row := q.db.QueryRow(ctx, patchSong,
		arg.SingerFk,
		arg.Name,
		arg.S3ObjectName,
		arg.ImageUrl,
		arg.Duration,
		arg.WeightBytes,
		arg.ReleasedAt,
		arg.UploadedAt,
		arg.ID,
	)
	var i Song
	err := row.Scan(
		&i.SongID,
		&i.SingerFk,
		&i.Name,
		&i.S3ObjectName,
		&i.ImageUrl,
		&i.Duration,
		&i.WeightBytes,
		&i.UploadedAt,
		&i.ReleasedAt,
	)
	return i, err
}

const patchSongs = `-- name: PatchSongs :exec
UPDATE songs SET
    singer_fk = COALESCE($1, singer_fk),
    name = COALESCE($2, name),
    s3_object_name = COALESCE($3, s3_object_name),
    image_url = COALESCE($4, image_url),
    duration = COALESCE($5, duration),
    weight_bytes = COALESCE($6, weight_bytes),
    released_at = COALESCE($7, released_at),
    uploaded_at = COALESCE($8, uploaded_at)
WHERE song_id = ANY($9::UUID[])
`

type PatchSongsParams struct {
	SingerFk     pgtype.UUID
	Name         pgtype.Text
	S3ObjectName pgtype.Text
	ImageUrl     pgtype.Text
	Duration     pgtype.Interval
	WeightBytes  pgtype.Int4
	ReleasedAt   pgtype.Timestamptz
	UploadedAt   pgtype.Timestamptz
	Ids          []uuid.UUID
}

func (q *Queries) PatchSongs(ctx context.Context, arg PatchSongsParams) error {
	_, err := q.db.Exec(ctx, patchSongs,
		arg.SingerFk,
		arg.Name,
		arg.S3ObjectName,
		arg.ImageUrl,
		arg.Duration,
		arg.WeightBytes,
		arg.ReleasedAt,
		arg.UploadedAt,
		arg.Ids,
	)
	return err
}

const releasedSongs = `-- name: ReleasedSongs :many
SELECT
    songs.song_id, songs.singer_fk, songs.name, songs.s3_object_name, songs.image_url, songs.duration, songs.weight_bytes, songs.uploaded_at, songs.released_at,
    ARRAY_AGG(feats.artist_fk ORDER BY feats.order_num)::UUID[] AS artists_ids
FROM songs
LEFT JOIN feats ON feats.song_fk = songs.song_id
WHERE
    -- Only released songs!
    released_at IS NOT NULL AND (
    -- All songs created by some artists
    (($1::BOOLEAN OR $2::BOOLEAN) AND singer_fk = ANY($3::UUID[])) OR
    -- All songs created by or featured some artists
    ($2::BOOLEAN AND $3::UUID[] <@ (
        SELECT ARRAY_AGG(feats.artist_fk)
        FROM feats
        WHERE song_fk = songs.song_id
        GROUP BY song_fk
    )) OR
    -- All songs matching name
    ($4::BOOLEAN AND name ILIKE CONCAT('%', $5::TEXT, '%')) OR
    -- Songs by IDs
    ($6::BOOLEAN AND song_id = ANY($7::UUID[]))
    )
GROUP BY songs.song_id
ORDER BY songs.uploaded_at DESC, name
LIMIT $9
OFFSET $8
`

type ReleasedSongsParams struct {
	BySinger   bool
	WithArtist bool
	SingersIds []uuid.UUID
	ByName     bool
	MatchName  string
	ByIds      bool
	Ids        []uuid.UUID
	Offsetv    int32
	Limitv     int32
}

type ReleasedSongsRow struct {
	Song       Song
	ArtistsIds []uuid.UUID
}

func (q *Queries) ReleasedSongs(ctx context.Context, arg ReleasedSongsParams) ([]ReleasedSongsRow, error) {
	rows, err := q.db.Query(ctx, releasedSongs,
		arg.BySinger,
		arg.WithArtist,
		arg.SingersIds,
		arg.ByName,
		arg.MatchName,
		arg.ByIds,
		arg.Ids,
		arg.Offsetv,
		arg.Limitv,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReleasedSongsRow
	for rows.Next() {
		var i ReleasedSongsRow
		if err := rows.Scan(
			&i.Song.SongID,
			&i.Song.SingerFk,
			&i.Song.Name,
			&i.Song.S3ObjectName,
			&i.Song.ImageUrl,
			&i.Song.Duration,
			&i.Song.WeightBytes,
			&i.Song.UploadedAt,
			&i.Song.ReleasedAt,
			&i.ArtistsIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveSong = `-- name: SaveSong :exec
WITH inserted_song AS (
    INSERT INTO songs (
    song_id,
    singer_fk,
    name,
    s3_object_name,
    image_url,
    duration,
    weight_bytes,
    uploaded_at,
    released_at) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9)
    RETURNING song_id
)
INSERT INTO feats (song_fk, artist_fk, order_num)
SELECT
    (SELECT song_id FROM inserted_song) AS song_fk,
    artist AS artist_fk,
    ROW_NUMBER() OVER () AS order_num
FROM UNNEST($10::UUID[]) AS artist
`

type SaveSongParams struct {
	SongID       uuid.UUID
	SingerFk     uuid.UUID
	Name         string
	S3ObjectName pgtype.Text
	ImageUrl     pgtype.Text
	Duration     pgtype.Interval
	WeightBytes  pgtype.Int4
	UploadedAt   time.Time
	ReleasedAt   pgtype.Timestamptz
	ArtistsIds   []uuid.UUID
}

func (q *Queries) SaveSong(ctx context.Context, arg SaveSongParams) error {
	_, err := q.db.Exec(ctx, saveSong,
		arg.SongID,
		arg.SingerFk,
		arg.Name,
		arg.S3ObjectName,
		arg.ImageUrl,
		arg.Duration,
		arg.WeightBytes,
		arg.UploadedAt,
		arg.ReleasedAt,
		arg.ArtistsIds,
	)
	return err
}

const song = `-- name: Song :one
SELECT
    songs.song_id, songs.singer_fk, songs.name, songs.s3_object_name, songs.image_url, songs.duration, songs.weight_bytes, songs.uploaded_at, songs.released_at,
    ARRAY_AGG(feats.artist_fk ORDER BY feats.order_num)::UUID[] AS artists_ids
FROM songs
LEFT JOIN feats ON feats.song_fk = songs.song_id
WHERE song_id = $1 AND released_at IS NOT NULL
GROUP BY songs.song_id
`

type SongRow struct {
	Song       Song
	ArtistsIds []uuid.UUID
}

func (q *Queries) Song(ctx context.Context, songID uuid.UUID) (SongRow, error) {
	row := q.db.QueryRow(ctx, song, songID)
	var i SongRow
	err := row.Scan(
		&i.Song.SongID,
		&i.Song.SingerFk,
		&i.Song.Name,
		&i.Song.S3ObjectName,
		&i.Song.ImageUrl,
		&i.Song.Duration,
		&i.Song.WeightBytes,
		&i.Song.UploadedAt,
		&i.Song.ReleasedAt,
		&i.ArtistsIds,
	)
	return i, err
}

const updateSong = `-- name: UpdateSong :one
UPDATE songs SET
    singer_fk = $2,
    name = $3,
    s3_object_name = $4,
    image_url = $5,
    duration = $6,
    weight_bytes = $7,
    released_at = $8,
    uploaded_at = $9
WHERE song_id = $1
RETURNING song_id, singer_fk, name, s3_object_name, image_url, duration, weight_bytes, uploaded_at, released_at
`

type UpdateSongParams struct {
	SongID       uuid.UUID
	SingerFk     uuid.UUID
	Name         string
	S3ObjectName pgtype.Text
	ImageUrl     pgtype.Text
	Duration     pgtype.Interval
	WeightBytes  pgtype.Int4
	ReleasedAt   pgtype.Timestamptz
	UploadedAt   time.Time
}

func (q *Queries) UpdateSong(ctx context.Context, arg UpdateSongParams) (Song, error) {
	row := q.db.QueryRow(ctx, updateSong,
		arg.SongID,
		arg.SingerFk,
		arg.Name,
		arg.S3ObjectName,
		arg.ImageUrl,
		arg.Duration,
		arg.WeightBytes,
		arg.ReleasedAt,
		arg.UploadedAt,
	)
	var i Song
	err := row.Scan(
		&i.SongID,
		&i.SingerFk,
		&i.Name,
		&i.S3ObjectName,
		&i.ImageUrl,
		&i.Duration,
		&i.WeightBytes,
		&i.UploadedAt,
		&i.ReleasedAt,
	)
	return i, err
}
